const fs = require('fs');
const path = require('path');
const request = require('request');
const RawSource = require('webpack-sources').RawSource;
const jsZip = require('jszip');
const remove = require('rimraf');
const zip = new jsZip();

class FileZiperAndUploader {
    constructor(options = []) {
        // 默认参数值
        const defaultValue = {
            url: 'http://localhost:8080/upload',
            zipName: 'source-map.zip',
            target: /\.map$/
        }
        //处理不同的参数传入值类型
        if (Array.isArray(options)) {
            this.task = options.map(item => ({ ...defaultValue, ...item }))
        } else {
            this.task = [{ ...defaultValue, ...options }];
        }

        //全部和非全部需要区分：有些文件并非通过编译生成 not all files generated by webpack.
        this.compilerList = this.task.filter(v => v.target !== 'all');

        this.allList = this.task.find(v => v.target === 'all');
    }

    createFolder = (compilation, opt, totalZipName = []) => {
        //添加下一个压缩任务文档
        const folder = zip.folder()
        for (let filename in compilation.assets) {
            //多任务压缩包不能互相包含
            if (opt.target.test(filename) && totalZipName.indexOf(filename) === -1) {
                const source = compilation.assets[filename].source();
                folder.file(filename, source);
            }
        }

        //开始压缩任务
        return new Promise((resolve, reject) => {
            zip.generateAsync({ type: "nodebuffer" }).then(content => {
                const outputpath = path.join(compilation.options.output.path, opt.zipName);
                //相对路径转换
                const relativePath = path.relative(
                    compilation.options.output.path,
                    outputpath
                );
                //资源写入
                compilation.assets[relativePath] = new RawSource(content);
                //抛出结束任务
                resolve('done');
            });
        })
    }

    apply(compiler) {

        //异步资源生成钩子
        compiler.hooks.emit.tapAsync('FileZiperAndUploader', async (compilation, callback) => {
            const totalZipName = this.task.map(v => v.zipName);
            const compilerList = this.compilerList;
            for (let i = 0; i < compilerList.length; i++) {
                if (compilerList[i].target !== 'all')
                    await this.createFolder(compilation, compilerList[i], totalZipName);
            }
            callback();
        });


        //异步：资源生成后的钩子
        compiler.hooks.afterEmit.tapAsync('FileZiperAndUploader', async (compilation, callback) => {
            let allFetch = [];

            //先行压缩all列表 TODO可安排在send
            await this.zipEntireFolder(compilation, this.allList);

            //添加任务队列
            for (let i = 0; i < this.task.length; i++) {
                const zPath = path.join(compilation.options.output.path, this.task[i].zipName);
                allFetch.push(this.send(zPath, this.task[i]));
            }

            //开始多任务处理请求
            Promise.all(allFetch).then(async res => {
                for (let i = 0; i < res.length; i++) {
                    //请求成功后删除zip包
                    const result = await new Promise((resolve) => {
                        remove(res[i], () => {
                            resolve('done');
                            console.log('zip file sent and removed');
                        });
                    })
                }
                callback();
            });
        })


        // compiler.hooks.afterEmit.tapAsync('FileZiperAndUploader', (compilation, callback) => {
        //     console.log('done....', compilation.options.output.path);
        //     const tarStream = new compressing.tar.Stream();
        //     tarStream.addEntry(compilation.options.output.path);
        //     tarStream.pipe(fs.createWriteStream(compilation.options.output.path + '/' + opt.zipName))
        //     .on('finish', d => {
        //         callback();
        //     });
        //     // compressing.gzip.compressFile(compilation.options.output.path, compilation.options.output.path + '.zip').then(res => {
        //     //     callback();
        //     // });
        // })
    }

    //读取目录及文件
    readDir(obj, nowPath, up = '') {
        const files = fs.readdirSync(nowPath);//读取目录中的所有文件及文件夹（同步操作）
        files.forEach((fileName, index) => {//遍历检测目录中的文件
            let _fileName = up + '/' + fileName;
            const fillPath = nowPath + "/" + fileName;
            const file = fs.statSync(fillPath);//获取一个文件的属性
            if (file.isDirectory()) {//如果是目录的话，继续查询
                this.readDir(obj, fillPath, _fileName);//重新检索目录文件
            } else {
                //压缩文件不计入all包 TODO 正对options 做过滤
                if (!/\.zip/.test(_fileName))
                    obj.file(_fileName, fs.readFileSync(fillPath));//压缩目录添加文件
            }
        });
    }

    //压缩整个打包文件 all时调用
    zipEntireFolder(compilation, opt) {
        return new Promise((reslove) => {
            var currPath = compilation.options.output.path;//文件的绝对路径 当前当前js所在的绝对路径
            this.readDir(zip, compilation.options.output.path);
            zip.generateAsync({//设置压缩格式，开始打包
                type: "nodebuffer",//nodejs用
                compression: "DEFLATE",//压缩算法
                compressionOptions: {//压缩级别
                    level: 9
                }
            }).then(function (content) {
                fs.writeFileSync(currPath + "/" + opt.zipName, content, "utf-8");//将打包的内容写入 当前目录下的 result.zip中
                reslove('done');
            });
        })
    }

    send(zipPath, opt) {
        //发送压缩后的资源包到指定的服务器
        return new Promise((reslove, reject) => {
            request.post(opt.url, {
                formData: {
                    token: opt.token,
                    description: 'Sent on ' + new Date(),
                    is_public: 1,
                    sqlfiles: fs.createReadStream(zipPath)
                },
                json: true,
            }, function (err, res, body) {
                if (err) {
                    reslove('err:', err);
                } else {
                    reslove(zipPath);
                }
            })
        })
    }
}

module.exports = FileZiperAndUploader;