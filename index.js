const fs = require('fs');
const path = require('path');
const request = require('request');
const RawSource = require('webpack-sources').RawSource;
const jsZip = require('jszip');
const remove = require('rimraf');
const find = require('find');
class FileZiperAndUploader {
    constructor(options = []) {
        // 默认参数值
        const defaultValue = {
            url: 'http://localhost:8080/upload',
            zipName: 'source-map.zip',
            target: /\.map$/
        }
        //处理不同的参数传入值类型
        if (Array.isArray(options)) {
            this.task = options.map(item => ({ ...defaultValue, ...item }))
        } else {
            this.task = [{ ...defaultValue, ...options }];
        }

        //全部和非全部需要区分：有些文件并非通过编译生成 not all files generated by webpack.
        this.compilerList = this.task.filter(v => v.target !== 'all');

        this.allList = this.task.filter(v => v.target === 'all');
    }

    createFolder = (compilation, opt, totalZipName = []) => {
        //添加下一个压缩任务文档
        const zip = new jsZip();
        const folder = zip.folder();
        for (let filename in compilation.assets) {
            //多任务压缩包不能互相包含
            if (opt.target.test(filename) && totalZipName.indexOf(filename) === -1) {
                const source = compilation.assets[filename].source();
                folder.file(filename, source);
            }
        }

        //开始压缩任务
        return new Promise((resolve, reject) => {
            zip.generateAsync({ type: "nodebuffer" }).then(content => {
                const outputpath = path.join(compilation.options.output.path, opt.zipName);
                //相对路径转换
                const relativePath = path.relative(
                    compilation.options.output.path,
                    outputpath
                );
                //资源写入
                compilation.assets[relativePath] = new RawSource(content);
                //抛出结束任务
                resolve('done');
            });
        })
    }

    apply(compiler) {

        //异步资源生成钩子
        compiler.hooks.emit.tapAsync('FileZiperAndUploader', async (compilation, callback) => {
            const totalZipName = this.task.map(v => v.zipName);
            const compilerList = this.compilerList;
            for (let i = 0; i < compilerList.length; i++) {
                if (compilerList[i].target !== 'all')
                    await this.createFolder(compilation, compilerList[i], totalZipName);
            }
            callback();
        });


        //异步：资源生成后的钩子
        compiler.hooks.afterEmit.tapAsync('FileZiperAndUploader', async (compilation, callback) => {
            let allFetch = [];

            //先行压缩all列表
            await this.zipEntireFolder(compilation, this.allList);

            //添加任务队列
            for (let i = 0; i < this.task.length; i++) {
                const zPath = path.join(compilation.options.output.path, this.task[i].zipName);
                allFetch.push(this.send(zPath, this.task[i]));
            }

            //开始多任务处理请求
            Promise.all(allFetch).then(async res => {
                for (let i = 0; i < res.length; i++) {
                    //请求成功后删除zip包
                    await new Promise((resolve) => {
                        remove(res[i], () => {
                            resolve('done');
                            console.log('zip file sent and removed');
                        });
                    })
                }
                callback();
            });
        })
    }

    //压缩整个打包文件 all时调用
    zipEntireFolder(compilation, opt = []) {
        const zip = new jsZip();
        return new Promise((reslove) => {
            var currPath = compilation.options.output.path;//文件的绝对路径 当前当前js所在的绝对路径
            find.file(currPath, file => {
                file.forEach( _fileName => {
                    // const _fn = _fileName.match(/(?<=[\/\\])[^\/\\.]+\.(?!zip).*$/);
                    const _fn = _fileName.replace(new RegExp(currPath), '');
                    if(!/\.zip/.test(_fn))
                        zip.file(_fn, fs.readFileSync(_fileName));//压缩目录添加文件
                });

                zip.generateAsync({//设置压缩格式，开始打包
                    type: "nodebuffer",//nodejs用
                    compression: "DEFLATE",//压缩算法
                    compressionOptions: {//压缩级别
                        level: 9
                    }
                }).then(content => {
                    if(Array.isArray(opt)) {
                        opt.forEach(v => {
                            fs.writeFileSync(currPath + "/" + v.zipName, content, "utf-8");//将打包的内容写入 当前目录下的 result.zip中
                        })
                    }
                    reslove('done');
                });
                
            });
           
        })
    }

    send(zipPath, opt) {
        //发送压缩后的资源包到指定的服务器
        return new Promise((reslove, reject) => {
            request.post(opt.url, {
                formData: {
                    token: opt.token,
                    description: 'Sent on ' + new Date(),
                    is_public: 1,
                    sqlfiles: fs.createReadStream(zipPath)
                },
                json: true,
            }, function (err, res, body) {
                if (err) {
                    reslove('err:', err);
                } else {
                    reslove(zipPath);
                }
            })
        })
    }
}

module.exports = FileZiperAndUploader;