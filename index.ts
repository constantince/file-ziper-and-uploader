import fs from 'fs';
import path from 'path';
import request from 'request';
import { RawSource } from 'webpack-sources';
import jsZip from 'jszip';
import remove from 'rimraf';
import find from 'find';
import { Task, SingleObject, FileZiperAndUploaderType, Comp } from './types/index';

class FileZiperAndUploader implements FileZiperAndUploaderType {
    task: Task;
    compilerList: Task
    allList: Task
    constructor(options: Task | SingleObject) {
        // 默认参数值
        const defaultValue = {
            url: 'http://localhost:8080/upload',
            zipName: 'source-map.zip',
            target: /\.map$/
        }
        //处理不同的参数传入值类型
        if (Array.isArray(options)) {
            this.task = options.map(item => ({ ...defaultValue, ...item }))
        } else {
            this.task = [{ ...defaultValue, ...options }];
        }

        //全部和非全部需要区分：有些文件并非通过编译生成 not all files generated by webpack.
        this.compilerList = this.task.filter(v => v.target !== 'all');

        this.allList = this.task.filter(v => v.target === 'all');
    }  

    createFolder = (compilation:any, opt: SingleObject, totalZipName: string[]): Promise<string> => {
        //添加下一个压缩任务文档
        const zip = new jsZip();
        const folder = zip.folder('');
        for (let filename in compilation.assets) {
            //多任务压缩包不能互相包含
            if ((<RegExp>opt.target).test(filename) && totalZipName.indexOf(filename) === -1) {
                const source = compilation.assets[filename].source();
                if(folder)
                    folder.file(filename, source);
            }
        }

        //开始压缩任务
        return new Promise((resolve, reject) => {
            zip.generateAsync({ type: "nodebuffer" }).then(content => {
                const outputpath = path.join(compilation.options.output.path, opt.zipName);
                //相对路径转换
                const relativePath = path.relative(
                    compilation.options.output.path,
                    outputpath
                );
                //资源写入
                compilation.assets[relativePath] = new RawSource(<any>content);
                //抛出结束任务
                resolve('done');
            });
        })
    }

    apply(compiler: any) {
        const emitAsync: Comp = async (compilation, callback) => {
            const totalZipName = this.task.map(v => v.zipName);
            const compilerList = this.compilerList;
            for (let i = 0; i < compilerList.length; i++) {
                if (compilerList[i].target !== 'all')
                    await this.createFolder(compilation, compilerList[i], totalZipName);
            }
            callback();
        }
        //异步资源生成钩子
        compiler.hooks.emit.tapAsync('FileZiperAndUploader', emitAsync);

        const afterEmit: Comp = async (compilation, callback) => {
            let allFetch: Promise<string>[] = [];

            //先行压缩all列表
            await this.zipEntireFolder(compilation, this.allList);

            //添加任务队列
            for (let i = 0; i < this.task.length; i++) {
                const zPath = path.join(compilation.options.output.path, this.task[i].zipName);
                allFetch.push(this.send(zPath, this.task[i]));
            }

            // //开始多任务处理请求
            Promise.all(allFetch).then(async res => {
                for (let i = 0; i < res.length; i++) {
                    //请求成功后删除zip包
                    await new Promise((resolve) => {
                        remove(res[i], () => {
                            resolve('done');
                            console.log('zip file sent and removed');
                        });
                    })
                }
                callback();
            });
        } 

        //异步：资源生成后的钩子
        compiler.hooks.afterEmit.tapAsync('FileZiperAndUploader', afterEmit)
    }

    //压缩整个打包文件 all时调用
    zipEntireFolder(compilation:any, opt: Task | SingleObject): Promise<string> {
        const zip = new jsZip();
        return new Promise((reslove) => {
            var currPath = compilation.options.output.path;//文件的绝对路径 当前当前js所在的绝对路径
            find.file(currPath, file => {
                file.forEach( _fileName => {
                    const _fn = path.relative(currPath, _fileName).replace(/\\/g, '/');
                    if(!/\.zip/.test(_fn))
                        zip.file(_fn, fs.readFileSync(_fileName));//压缩目录添加文件
                });

                zip.generateAsync({//设置压缩格式，开始打包
                    type: "nodebuffer",//nodejs用
                    compression: "DEFLATE",//压缩算法
                    compressionOptions: {//压缩级别
                        level: 9
                    }
                }).then(content => {
                    if(Array.isArray(opt)) {
                        opt.forEach(v => {
                            fs.writeFileSync(currPath + "/" + v.zipName, content, "utf-8");//将打包的内容写入 当前目录下的 result.zip中
                        })
                    }
                    reslove('done');
                });
                
            });
           
        })
    }

    send(zipPath: string, opt: SingleObject): Promise<string> {
        //发送压缩后的资源包到指定的服务器
        return new Promise(reslove => {
            request.post(opt.url, {
                formData: {
                    token: opt.token,
                    description: 'Sent on ' + new Date(),
                    is_public: 1,
                    sqlfiles: fs.createReadStream(zipPath)
                },
                json: true,
            }, function (err: any): void {
                if (err) {
                    reslove('err:' + err);
                } else {
                    reslove(zipPath);
                }
            })
        })
    }
}

export default FileZiperAndUploader;